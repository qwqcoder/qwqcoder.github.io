import{_ as a,c as n,b as t,o as e}from"./app-aVWlajFf.js";const l={};function p(c,s){return e(),n("div",null,[...s[0]||(s[0]=[t(`<h2 id="引入" tabindex="-1"><a class="header-anchor" href="#引入"><span>引入</span></a></h2><ul><li><p><code>&lt;script&gt;</code></p><ul><li><code>type</code> 属性用于指定脚本的类型</li></ul><ol><li>type = &quot;text/javascript&quot;</li></ol><blockquote><p>这是传统的 JavaScript 脚本类型声明，也是早期 HTML 中最常用的方式。在 HTML5 中，这个值可以省略，因为浏览器会默认将 <code>&lt;script&gt;</code> 标签视为 JavaScript 脚本。</p></blockquote><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;这是普通脚本&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>type=&quot;module&quot;</li></ol><blockquote><p>表示当前脚本是一个 ES6 模块（Module），可以使用 <code>import</code> 和 <code>export</code> 语法进行模块导入导出，且模块内的变量默认具有块级作用域（不会污染全局）。</p></blockquote><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">  <span class="token keyword">import</span> <span class="token punctuation">{</span> func <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./module.js&#39;</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h2><p>闭包指子函数可以访问外部作用域变量的函数特性，即使在子函数作用域外也可以访问。如果没有闭包那么在处理事件绑定，异步请求时都会变得困难。</p><ul><li>JS中的所有函数都是闭包</li><li>闭包一般在子函数本身作用域以外执行，即延伸作用域</li></ul><h2 id="异步编程" tabindex="-1"><a class="header-anchor" href="#异步编程"><span>异步编程</span></a></h2><h2 id="原型" tabindex="-1"><a class="header-anchor" href="#原型"><span>原型</span></a></h2><p><img src="https://s2.loli.net/2025/08/27/awTVyLqu5QMj2C9.png" alt="image-20250827221207251"></p><ul><li><code>prototype</code> 原型</li><li><code>__prototype__</code> 隐式原型，在对象属性中用 <code>[[prototype]]</code> 表示，所有对象都有一个隐式原型指向==方法对象==的原型</li><li><code>constructor</code> 构造器，原型包含一个 <code>constructor</code> 指向方法函数</li></ul>`,9)])])}const i=a(l,[["render",p]]),u=JSON.parse('{"path":"/blogs/frontend/js.html","title":"js","lang":"en-US","frontmatter":{"title":"js","tags":["js"],"data":"2025-09-14T00:00:00.000Z"},"headers":[{"level":2,"title":"引入","slug":"引入","link":"#引入","children":[]},{"level":2,"title":"闭包","slug":"闭包","link":"#闭包","children":[]},{"level":2,"title":"异步编程","slug":"异步编程","link":"#异步编程","children":[]},{"level":2,"title":"原型","slug":"原型","link":"#原型","children":[]}],"git":{"createdTime":1757862184000,"updatedTime":1757862184000,"contributors":[{"name":"qwqcoder","email":"qwqcoder@163.com","commits":1}]},"filePathRelative":"blogs/frontend/js.md"}');export{i as comp,u as data};
